Як побачимо далі, на новостворений тип можна навіть поширити набір стандартних операцій, наприклад, визначивши операцію збільшення місяця на ціле число, що дасть змогу писати вирази на кшталт theMonth+5.

І, нарешті, крім процедурної, об’єктної та об’єктно-орієнтованої парадигм, C++ реалізує також для кожної з них парадигму узагальненого програмування, надаючи можливість використання узагальнених функцій і параметризованих класів, але про це далі.

1.5. Програмні середовища

Від складання програмістом до виконання комп’ютером програма проходить доволі тривалий процес оброблення спеціальними службовими програмами, які становлять систему автоматизації програмування. З часом слово «автоматизація» випало із наведеного словосполучення, внаслідок чого воно перетворилося на «систему програмування». Ця система складається з кількох компонент, а саме препроцесора (preprocessor), компілятора (compiler) та компонувальника (linker), а також засобів підтримки етапу виконання, зокрема налагоджувача (debugger), об’єднаних спільним інтерфейсом у так зване універсальне середовище розробки програм. Прикладами таких середовищ можуть бути система програмування Visual C++ та діалогове середовище розробки програм Developer Studio.

Головна особливість підготовки програми до виконання полягає в тому, що програму збирають із багатьох, часом різнорідних, складових частин, об’єднаних у програмний проект (software project). Кожну програмну розробку оформлюють як окремий проект, який зазвичай складається з багатьох різнорідних файлів. Файли першого типу називають вхідними (source file, исходный файл), вони містять тексти, написані певною мовою програмування. Робота над проектом може бути достатньо тривалою, в її процесі виникатимуть нові вхідні файли, які додаватимуться до наявних. Тому в кожен момент часу частина вхідних файлів може виявитися вже готовою до використання, тобто попередньо відкомпільованою. Цю частину використовують у вигляді готових машинних кодів, що зберігаються в проекті як особливі об’єктні файли (object file), котрі складають другий тип файлів програмного проекту. Система програмування автоматично відстежує необхідність повторного компілювання кожного вхідного файлу. Компіляції підлягає кожен новий файл, долучений до проекту, а також будь-який інший файл після внесений до нього змін.

Крім спеціально розроблених власних кодів, проекти можуть використовувати стандартне програмне забезпечення, що зберігається в системний бібліотеках, передбачена також можливість створення і подальшого використання власних бібліотек. C++ послідовно продовжує закладену ще авторами мови C тенденцію широкого використання програмних бібліотек. Зокрема, мовою не визначено ніяких способів зв’язку програми з операційною системою — ці функції повністю перекладено на системні бібліотеки.

Вже упродовж не одного десятиріччя під час складання великих за розмірами програм використовують принцип структурної декомпозиції. Логічним складовим частинам програми (у процедурному програмуванні це процедури і функції, у більш розвинених парадигмах — модулі або класи) відповідають фізичні складові — файли, що містять ці окремі завершені логічні частини, одну або декілька разом. Одночасне використання в одному програмному проекті багатьох файлів з текстами різних частин програми одержало назву роздільної компіляції (separate compilation), яка, без сумніву, стала одним із найбільших досягнень систем програмування. Завдяки їй програму тепер поділено на частини, які називаються одиницями трансляції (translation unit). З використанням роздільної компіляції стало можливим колективне розроблення великих програм: окремі розробники зайняті підготовкою кожен своїх файлів.

Програмування — це діяльність, яка потребує великої організованості. Прийнято не тільки розділяти текст програми на структурні частини, але й розрізняти описові та виконавчі частини текстів. Тому під час складання програм дотримуються певних правил доброго тону, одне з яких полягає в необхідності розподілення визначень і обчислень між вхідними файлами двох типів: файлами заголовків (header) і файлами реалізації (implementation). Особливий компонент системи програмування — препроцесор — у відповідності з директивами, розміщеними, як правило, на початку вхідного файлу, приєднує до нього відповідні файли заголовків. Вони містять інформацію про те, які функції, об’єкти або класи, визначені поза цим вхідним файлом, можуть бути використані в ньому. Один файл заголовків можна приєднувати до багатьох вхідних файлів, які використовуватимуть оголошені в ньому конструкції. Приєднанням потрібних заголовних файлів препроцесор готує вхідні файли до подальшої обробки компілятором. Тому вміст вхідного файлу для компілятора, взагалі кажучи, відрізняється від вмісту вхідного файлу, складеного розробником, оскільки обробка препроцесором може значно його змінити. Далі розглянемо, в яких межах варто зосередити цю обробку. Набір пов’язаних один з одним заголовних і вхідних файлів, з яких складається проект, в сукупності утворює вхідну програму, яку система програмування перетворюватиме на машинний код. Машинний код генерується у два етапи. На першому компілятор генерує так звані об’єктні коди (object code), по одному для кожного файлу реалізації (за заголовними файлами об’єктні не генеруються). Коди називають об’єктними (від слова «objective», що англійською мовою означає «мета»), оскільки їхнє створення є метою роботи компілятора, який становить центральну частину системи програмування. Інша її частина, названа компонувальником (linker), збирає об’єктні файли в одну виконавчу програму (executable program, exe-file), приєднуючи до неї також об’єктні коди зі стандартних або власних бібліотек проекту.

Ми розглядатимемо систему програмування такою мірою, наскільки вона впливає на написання та організацію текстів вхідних програм. За детальним ознайомленням із засобами і можливостями систем програмування відсилаємо до системної документації та спеціальної літератури.

Ось типовий сценарій підготовки програми.

Система програмування працює з програмними проектами, де розміщують файли вхідної програми. Розглянемо, наприклад, проект sqrt. До файлу реалізації root.cpp запишемо текст функції root для обчислення квадратного кореня, а програмний код для її виклику помістимо у файл реалізації main.cpp.

Пам’ятаймо, що компіляція цих двох файлів виконуватиметься нарізно. Виникає запитання: звідки під час компіляції файлу main.cpp компілятор візьме відомості про ідентифікатор root? У принципі, можливі два вирішення. Перше — це перемістити текст функції з файлу root.cpp до файлу main.cpp, де функцію використано. Проте це було б не дуже вдалим виходом, оскільки незрозуміло, як одну й ту ж функцію розмістити у різних вхідних файлах, де її також можна було б викликати. Друге вирішення, а саме воно прийняте в системах програмування, полягає у створенні допоміжного заголовного файлу root.h, який міститиме не всю інформацію про функцію root, а лише ту, що необхідна для обробки її виклику компілятором, — так звану сигнатуру функції.
